/// Класс BinarySearchTree бинарного дерева
/// @author Будаев Г.Б.
#pragma once
#include "TreeNode.h"
#include <stack>

/// <summary>
/// шаблонный класс бинарное дерево поиска, использующий класс узел дерева
/// </summary>
/// <typeparam name="T"></typeparam>
template<class T>
class BSTree
{
private:
    TreeNode<T>* root;/// корень
    TreeNode<T>* curr;/// текущий узел
   
    /// Рекурсивная функция для удаления дерева
    void DeleteTree(TreeNode<T>* node) {
        if (node) {
            DeleteTree(node->Left());   // Рекурсивно удаляем левое поддерево
            DeleteTree(node->Right());  // Рекурсивно удаляем правое поддерево
            delete node;                // Удаляем текущий узел
        }
    }

public:
    /// Конструктор без параметров
    BSTree() {
        root = new TreeNode<T>();
        curr = new TreeNode<T>();
    };

    
    /// Конструктор с параметром - корень дерева
    BSTree(const T& node) {
        this->Insert(node);
    };

    /// Конструктор копирования
    BSTree(const BSTree<T>& tree) {
        root = CopyTree(tree->root);
    }

    /// Оператор присваивания
    BSTree<T>& operator=(const BSTree<T>& tree) {
        if (this == &tree) {
            return *this;               /// Проверка на самоприсваивание
        }
        DeleteTree(root);               /// Освобождаем память текущего дерева
        root = CopyTree(tree->Root());  /// Копируем узлы из исходного дерева в новое дерево
        return *this;                   /// Возвращаем ссылку на текущий объект
    }

    /// todo: конструткор перемещения, оператор присваивания перемещения
    


    /// Деструктор
    ~BSTree() {
        DeleteTree(root);   
    };

    /// Очищение дерева
    void ClearTree() {
        DeleteTree(root);
        root = nullptr;
    }

    /// Вернуть данные
    T Data(TreeNode<T>* curr) const
    {
        return curr->Data();
    }

    /// Вернуть корень
    TreeNode<T>* Root() {
        return root;
    }

    /// Установить корень
    void SetRoot(TreeNode<T>* newRoot) {
        root = newRoot;
    }

    /// Вставка
    void Insert(const T& key) {
        root->Insert(key);
    }
    
    /// Поиск
    TreeNode<T>* Search(const T& key) {
        return root->Search(key);
    }

    /// Размер
    int Size() {
        return root->Size();
    }

    /// Глубина
    int Depth() {
        return root->Depth();
    }

    /// Найти минимальный
    TreeNode<T>* FindMin() {
        return root->FindMin();
    }

    /// Найти максимальный
    TreeNode<T>* FindMax() {
        return root->FindMax();
    }

    /// Следующий наибольший для узла
    TreeNode<T>* Successor(const T& key) {
        return root->Successor(key); 
    }

    /// Удаление узла
    void Remove(const T& key) {
        root = root->Remove(root, key);
    }

    /// Добавить в массив LNR
    void AddToArrayLNR(T arr[]) {
        int i = 0;
        root->AddToArrayLNR(arr,i);
    }

    /// Копировать дерево
    BSTree<T>* CopyTree() {
        BSTree<T>* copiedTree = new BSTree<T>();
        copiedTree->SetRoot(root->CopyTree());
        return copiedTree;
    }


    /// <summary>
    /// шаблонный класс итератор в классе BinarySearchTree, как в итерируемом
    /// с порядком обхода в глубину LNR
    /// </summary>
    /// <typeparam name="T"></typeparam>
    template<class T>
    class Iterator {
    private:
        TreeNode<T>* current; // Указатель на текущий узел
        std::stack<TreeNode<T>*> nodeStack;  // Стек для обхода дерева

        // Заполняет стек узлами левого поддерева, начиная с заданного узла
        void FillStack(TreeNode<T>* node)
        {
            // пока указатель - не пустой узел
            while (node) {
                // добавляем в стек
                nodeStack.push(node);
                // переход к левому узлу
                node = node->Left();
            }
        }
    public:
        /// Конструктор без параметров
        Iterator(TreeNode<T>* node) : current(node) 
        {
            // Заполняем стек начальным состоянием
            FillStack(current);
            // Если стек не пустой, получаем следующий узел из стека
            if (!nodeStack.empty()) {
                current = nodeStack.top();
                nodeStack.pop();
            }
            else
                current = nullptr;
        }

        /// Оператор разыменования
        T operator*() const {
            return current->Data();
        }

        /// Оператор префиксного инкремента
        /// *this возвращает ссылку на текущий объект итератора
        /// с обходом LNR
        Iterator<T>& operator++() {
            // Если стек пустой - выход
            if (nodeStack.empty()) {
                current = nullptr;
                return *this;
            }
            // Если стек не пустой, получаем следующий узел из стека
            current = nodeStack.top();
            nodeStack.pop();

            // Заполняем стек правым поддеревом текущего узла
            FillStack(current->Right());

            return *this;
        }

        /// Оператор постфиксного инкремента
        /// temp для сохранения состояния до перехода к следующему
        /// с обходом LNR
        Iterator<T> operator++(int) {
            Iterator temp = *this;
            ++(*this);
            return temp;
        }

        /// Оператор "равно"
        bool operator==(const Iterator<T>& it) const {
            return current == it.current;
        }

        /// Оператора "не равно"
        bool operator!=(const Iterator<T>& it) const {
            return !(*this == it);
        }
    };

    /// Первый элемент списка
    Iterator<T> begin() const {
        return Iterator<T>(root);
    }

    /// Элемент, следующий за последним элементом списка
    Iterator<T> end() const {
        return Iterator<T>(nullptr);
    }
};










//// Функция для обхода дерева и применения функции к каждому элементу
//template<typename T>
//void apply(TreeNode<T>* root, T(*func)(T)) {
//    if (root != nullptr) {
//        // Применяем функцию к текущему элементу
//        root->SetData(func(root->Data()));
//        // Рекурсивно обходим левое и правое поддеревья
//        apply(root->Left(), func);
//        apply(root->Right(), func);
//    }
//}
